---
title: 'teal8: My CHIP-8 Implementation'
image:
    path: /images/teal8.png
    alt: teal8 screenshot
date: 2025-10-16
permalink: /posts/2025/10/teal8/
tags:
  - emulator
  - interpreter
  - development
  - emudev
---

<html>
    <head>
        <strong style="font-size: 16px">
            CHIP-8 is an interpreted programming language developed by Joseph Weisbecker.
            teal8 is an interpreter for running CHIP-8 ROMs.
        </strong>
    </head>

    <body>

        <div style="text-align: center">
            <a href="https://github.com/jacob-thompson/teal8">
                <img src="/images/teal8Logo.png" style="padding: 35px">
            </a>
        </div>

        <h1 style="text-align: center; padding-top: 5px">
            CHIP-8
        </h1>

        <p style="text-indent: 2em">
            CHIP-8 is a language interpreter that allowed for
                <b>easy game programming</b>.
            It was used in the 70s and 80s on computers
                such as the COSMAC VIP and the TELMAC 1800.
            The interpreter is very small due to the memory limitations
                of these computers, as the COSMAC VIP had 2K and the TELMAC 1800 had 4K.
        </p>

        <h1 style="text-align: center; padding-top: 10px">
            teal8
        </h1>

        <p style="text-indent: 2em">
            Taking some inspiration from around the internet, I decided to create an
                implementation of CHIP-8 as a means of trying out emulation development
                and simply having fun.
            I also wanted to sharpen my skills with C, as I feel that the skills gained
                through working with C are more broadly applicable across all of
                software development than those from any other programming language.
        </p>

        <h2 style="text-align: center">
            Memory
        </h2>

        <p style="text-indent: 2em">
            All CHIP-8 programs, with few exceptions, start at memory address
                <code>0x200</code>.
            The reason CHIP-8 programs begin at this address
                is because the interpreter used to live
                between addresses <code>0x000</code>-<code>0x1FF</code>
                on the COSMAC VIP and the TELMAC 1800.
            Most implementations of CHIP-8, including my own, provide
                <b>4K</b> of accessible and byte-addressable memory.
        </p>

        <h3 style="text-align: center">
            Implementation of Memory
        </h3>

        <p style="text-indent: 2em">
            We will implement the memory layout as an array
                of 4096 bytes (unsigned 8-bit integers):
            <br><code style="display: block; white-space: pre-wrap"><br>
#define MEMORY_BYTES 0x1000 // 4096 decimal

...

uint8_t memory[MEMORY_BYTES]; // 4KB memory
            </code>
        </p>

        <p style="text-indent: 2em">
            teal8 writes programs into memory starting from
                memory address <code>0x200</code>:
            <br><code style="display: block; white-space: pre-wrap">
#define PROGRAM_START_ADDRESS 0x200 // 512 decimal

...

chip8->pc = PROGRAM_START_ADDRESS;
while (chip8->pc < MEMORY_BYTES && fread(&chip8->memory[chip8->pc], 1, 1, rom) == 1)
    chip8->pc++;
            </code>
        </p>

        <h2 style="text-align: center">
            Font
        </h2>

        <p style="text-indent: 2em">
            CHIP-8 interpreters have <b>built-in</b> fonts that are drawn onto the screen
                just like sprites.
            Each font character is 4px wide and 5px tall.
            These font character sprites are represented in bytes as
                sequences of five hexadecimal numbers, with each
                hexadecimal number representing a row of 4px.
        </p>

        <p style="text-indent: 2em">
            The location in memory at which you store the font data does not
                matter since CHIP-8 contains an instruction for setting
                the index register to a character's address.
            For this reason, modern interpreters typically use some of the unused memory
                addresses between <code>0x000</code>-<code>0x1FF</code>
                to store font data.
        </p>

        <h3 style="text-align: center">
            Implementation of Font
        </h3>

        <p style="text-indent: 2em">
            Font data can be represented as an array of 80 bytes.
            We will store font data betwen memory addresses <code>0x000</code>
                and <code>0x050</code>:
            <br><code style="display: block; white-space: pre-wrap">
#define FONT_START_ADDRESS 0x000 // 0 decimal
#define FONT_BYTES 0x50 // 80 decimal

...

uint8_t font[FONT_BYTES] = {
    0xF0, 0x90, 0x90, 0x90, 0xF0, // 0
    0x20, 0x60, 0x20, 0x20, 0x70, // 1
    0xF0, 0x10, 0xF0, 0x80, 0xF0, // 2
    0xF0, 0x10, 0xF0, 0x10, 0xF0, // 3
    0x90, 0x90, 0xF0, 0x10, 0x10, // 4
    0xF0, 0x80, 0xF0, 0x10, 0xF0, // 5
    0xF0, 0x80, 0xF0, 0x90, 0xF0, // 6
    0xF0, 0x10, 0x20, 0x40, 0x40, // 7
    0xF0, 0x90, 0xF0, 0x90, 0xF0, // 8
    0xF0, 0x90, 0xF0, 0x10, 0xF0, // 9
    0xF0, 0x90, 0xF0, 0x90, 0x90, // A
    0xE0, 0x90, 0xE0, 0x90, 0xE0, // B
    0xF0, 0x80, 0x80, 0x80, 0xF0, // C
    0xE0, 0x90, 0x90, 0x90, 0xE0, // D
    0xF0, 0x80, 0xF0, 0x80, 0xF0, // E
    0xF0, 0x80, 0xF0, 0x80, 0x80  // F
};

...

for (int i = 0x0; i < FONT_BYTES; i++)
    memory[FONT_START_ADDRESS + i] = font[i];
            </code>
        </p>

        <h2 style="text-align: center">
            Registers
        </h2>

        <p style="text-indent: 2em">
            CHIP-8 contains 16 <b>data registers</b> used for storing bytes.
            These registers are called <code>V0</code>...<code>VF</code>.
            <code>VF</code> is used for carrying when using arithmetic instructions,
                and for collision detection when drawing sprites.
        </p>

        <p style="text-indent: 2em">
            CHIP-8 contains one <b>address register</b>, <code>I</code>.
                This register is 2-bytes wide and is used for pointing at locations
                in memory.
        </p>

        <p style="text-indent: 2em">
            CHIP-8 contains a <b>program counter</b>,
                internally referred to as <code>PC</code>.
            The 2-byte counter is used for pointing at the current instruction in memory.
        </p>

        <p style="text-indent: 2em">
            CHIP-8 contains two timers that are simply 8-bit numbers that are
                decremented ~60 times per second when non-zero.
            One of these timers is the <b>delay timer</b>, which is generally used
                to make delay loops.
            The other timer is the <b>sound timer</b>, which is used to control the
                sound since the system will beep while the timer is zero.
        </p>

        <p style="text-indent: 2em">
            CHIP-8 has a <b>stack</b> of 16 levels, each able to store two-byte addresses.
            The stack is used to call subroutines (push) and return from them (pop).
        </p>

        <h3 style="text-align: center">
            Implementation of Registers
        </h3>

        <p style="text-indent: 2em">
            The data registers are implemented as an array of 16 bytes:
            <br><code style="display: block; white-space: pre-wrap">
#define REGISTERS 16

...

uint8_t v[REGISTERS]; // 16 8-bit registers (V0 to VF)
            </code><br>
        </p>

        <p style="text-indent: 2em">
            The address register is implemented as a 16-bit value:
            <br><code style="display: block">
uint16_t i; // 16-bit address register
            </code><br>
        </p>

        <p style="text-indent: 2em">
            The program counter is implemented as a 16-bit value,
                similarly to <code>I</code>:
            <br><code style="display: block">
uint16_t pc; // program counter
            </code>
        </p>

        <p style="text-indent: 2em">
            The timers are implemented as their own structure.
            This structure contains two 8-bit values, and one bigger value used to
                handle the timing of decrements:
            <br><code style="display: block; white-space: pre-wrap">
typedef struct timers {
    uint8_t delay;
    uint8_t sound;
    uint32_t lastUpdate;
} timers;
            </code><br>
        </p>

        <p style="text-indent: 2em">
            The stack is also implemented as its own structure.
            The stack structure contains an array of 16 2-byte addresses,
                and a byte value used as a pointer to the top of the stack.
            <br><code style="display:block; white-space: pre-wrap">
#define STACK_SIZE 16 // 16 levels of stack

typedef struct stack {
    uint16_t s[STACK_SIZE]; // 16 addresses
    uint8_t sp; // stack pointer index (0x0-0xF)
} stack;
            </code>
        </p>

        <h2 style="text-align: center">
            Display
        </h2>

        <p style="text-indent: 2em">
            The CHIP-8 display is 64px wide and 32px tall.
            Since the display is monochrome, each pixel is either
                <em>on</em> or <em>off</em>.
        </p>

        <h3 style="text-align: center">
            Implementation of Display
        </h3>

        <p style="text-indent: 2em">
            To understand the display implementation, I recommend reading some
                of the relevant
                <a href="https://github.com/jacob-thompson/teal8/blob/main/include/display.h">
                source code</a>
                to get the full picture.
        </p>

        <p style="text-indent: 2em">
            In short, since we are using the <code>SDL2</code> library,
                pixels and their display states are handled as a list of
                dynamically allocated <code>SDL_Rect</code>s and <code>SDL_bool</code>s:
            <br><code style="display: block; white-space: pre-wrap">
SDL_Rect *pixels;
SDL_bool *pixelDrawn;
            </code>
        </p>

        <p style="text-indent: 2em">
            The display structure also contains the <b>window</b> and the <b>renderer</b>,
                which is used to draw the pixels on screen and handle events:
            <br><code style="display: block; white-space: pre-wrap">
SDL_Window *window;
SDL_Renderer *renderer;
            </code>
        </p>

        <p style="text-indent: 2em">
            The only SDL events that the interpreter needs to worry about are
                <code>KEYUP</code>, <code>KEYDOWN</code>, and <code>QUIT</code> events.
            The interpreter stores the states of each key in arrays, and
                the arrays are updated as needed while processing SDL events:
            <br><code style="display: block; white-space: pre-wrap">
    SDL_bool keyDown[KEY_COUNT];
    SDL_bool keyUp[KEY_COUNT];
            </code>
        </p>

        <h2 style="text-align: center">
            Instructions
        </h2>

        <p style="text-indent: 2em">
            From David Winter's <em>CHIP8</em> document:
            <br><code style="display: block; white-space: pre-wrap">
NNN is an address,
KK is an 8 bit constant
X and Y are two 4 bits constants

	0NNN	Call 1802 machine code program at NNN (not implemented)
	00CN		Scroll down N lines (***)
	00FB		Scroll 4 pixels right (***)
	00FC		Scroll 4 pixels left (***)
	00FD		Quit the emulator (***)
	00FE		Set CHIP-8 graphic mode (***)
	00FF		Set SCHIP graphic mode (***)
	00E0		Erase the screen
	00EE		Return from a CHIP-8 sub-routine
	1NNN	Jump to NNN
	2NNN	Call CHIP-8 sub-routine at NNN (16 successive calls max)
	3XKK	Skip next instruction if VX == KK
	4XKK	Skip next instruction if VX != KK
	5XY0		Skip next instruction if VX == VY
	6XKK	VX = KK
	7XKK	VX = VX + KK
	8XY0		VX = VY
	8XY1		VX = VX OR VY
	8XY2		VX = VX AND VY
	8XY3		VX = VX XOR VY (*)
	8XY4		VX = VX + VY, VF = carry
	8XY5		VX = VX - VY, VF = not borrow (**)
	8XY6		VX = VX SHR 1 (VX=VX/2), VF = carry
	8XY7		VX = VY - VX, VF = not borrow (*) (**)
	8XYE		VX = VX SHL 1 (VX=VX*2), VF = carry
	9XY0		Skip next instruction if VX != VY
	ANNN	I = NNN
	BNNN	Jump to NNN + V0
	CXKK	VX = Random number AND KK
	DXYN	Draws a sprite at (VX,VY) starting at M(I). VF = collision.
			If N=0, draws the 16 x 16 sprite, else an 8 x N sprite.
	EX9E		Skip next instruction if key VX pressed
	EXA1		Skip next instruction if key VX not pressed
	FX07		VX = Delay timer
	FX0A		Waits a keypress and stores it in VX
	FX15		Delay timer = VX
	FX18		Sound timer = VX
	FX1E		I = I + VX
	FX29		I points to the 4 x 5 font sprite of hex char in VX
	FX33		Store BCD representation of VX in M(I)...M(I+2)
	FX55		Save V0...VX in memory starting at M(I)
	FX65		Load V0...VX from memory starting at M(I)
	FX75		Save V0...VX (X<8) in the HP48 flags (***)
	FX85		Load V0...VX (X<8) from the HP48 flags (***)

(*): Used to be undocumented (but functional) in the original docs.

 (**): When you do VX - VY, VF is set to the negation of the borrow. This means that if VX is superior or equal to VY, VF will be set to 01, as the borrow is 0. If VX is inferior to VY, VF is set to 00, as the borrow is 1.

 (***):	SCHIP Instruction. Can be used in CHIP8 graphic mode.
            </code>
        </p>

        <h3 style="text-align: center">
            Implementation of Instructions
        </h3>

        <p style="text-indent: 2em">
            All source code relevant to <b>fetching</b>, <b>decoding</b>,
                and <b>executing</b> instructions/opcodes can be found
                in these two functions that are declared in
                <code>include/emulator.h</code> and defined in
                <code>src/emulator.c</code>:
            <br><code style="display: block; white-space: pre-wrap">
uint16_t fetchOpcode(emulator *chip8);
void decodeAndExecuteOpcode(emulator *chip8, unsigned short opcode);
            </code>
        </p>

        <p style="text-indent: 2em">
            These functions are called directly from the main function.
            They represent the heart of the interpreter's main loop:
            <br><code style="display: block; white-space: pre-wrap">
/* fetch, decode, and execute opcode */
opcode = fetchOpcode(&chip8);
chip8.pc += 2; // increment program counter
decodeAndExecuteOpcode(&chip8, opcode);
            </code>
        </p>

        <h2 style="text-align: center">
            What I Learned: Emulation Development
        </h2>

        <p style="text-indent: 2em">
            CHIP-8 is widely considered to be the best project for getting into
                emulation development, and I certainly agree with this idea.
            This project has <em>tremendously</em> helped me understand the
                absolute basics of emulation, and I feel excited to eventually
                take on a new project of this sort.
        </p>

        <p style="text-indent: 2em">
            Another thing that I learned from this project is working with
                hexadecimal values.
            This was a new concept for me, but it is certainly not complicated.
            I feel that working with these values is not at all scary once you
                realize that hexadecimal values are merely different
                representations of the decimal values you're used to.
        </p>

        <h2 style="text-align: center">
            Sources
        </h2>

        <p style="text-indent: 2em">
            All information provided here is based off of
                <a href="https://pong-story.com/chip8/">
                David Winter's CHIP-8 Emulation Page</a>
            and
            <a href="https://github.com/tobiasvl">
            tobiasvl</a>'s
            <a href="https://tobiasvl.github.io/blog/write-a-chip-8-emulator/">
            Guide To Making a CHIP-8 Emulator</a>.
        </p>

    </body>

</html>
